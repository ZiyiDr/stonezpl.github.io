<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张珮磊想静静</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://stonezpl.github.io/"/>
  <updated>2019-04-03T12:20:42.078Z</updated>
  <id>https://stonezpl.github.io/</id>
  
  <author>
    <name>张珮磊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis分布式锁——简单实现</title>
    <link href="https://stonezpl.github.io/2019/04/03/redis/"/>
    <id>https://stonezpl.github.io/2019/04/03/redis/</id>
    <published>2019-04-03T08:32:01.000Z</published>
    <updated>2019-04-03T12:20:42.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近项目当中需要处理分布式系统中的并发问题，自然地想到了引入分布式锁，本文旨在讲述用redis简单的实现分布式锁，对于复杂的类似于redis集群问题、为什么不用zk等，自己也在学习，希望可以以后有机会分享</p><h2 id="分布式锁的可靠性保证"><a href="#分布式锁的可靠性保证" class="headerlink" title="分布式锁的可靠性保证"></a>分布式锁的可靠性保证</h2><ol><li>在过期时间内，只有一个客户端持有锁</li><li>在客户端持有锁期间短暂崩溃或者redis发生短暂崩溃时，不会有死锁状态</li><li>加锁和解锁必须是同一客户端，加锁和解锁必须是同一个客户端</li></ol><a id="more"></a><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><blockquote><p>项目当中的实现<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title">lock</span><span class="hljs-params">(String key)</span> </span>&#123;</span><br><span class="line">    Long nowTIme = System.nanoTime();</span><br><span class="line">    <span class="hljs-comment">//TIMEOUT_NANO：超时时间</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (TIMEOUT_NANO &gt; System.nanoTime() - nowTIme) &#123;</span><br><span class="line">        <span class="hljs-keyword">long</span> expires = System.nanoTime() + EXPIRE_NANO;</span><br><span class="line">        <span class="hljs-comment">//锁到期时间</span></span><br><span class="line">        String expiresStr = String.valueOf(expires);</span><br><span class="line">        <span class="hljs-comment">//putIfAbsent: setnx命令</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (putIfAbsent(key, expiresStr)) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//当redis存在这个key的时候，取出这个key，判断是否超时</span></span><br><span class="line">        String currentValue = get(key);</span><br><span class="line">        <span class="hljs-comment">//判断锁是否已经过期，过期则重新设置并获取</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (currentValue != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(Long.parseLong(currentValue) &lt; System.nanoTime() - EXPIRE_NANO)&#123;</span><br><span class="line">                <span class="hljs-comment">//设置锁并返回旧值：getSet</span></span><br><span class="line">                String oldValue = getAndSet(key, expiresStr);</span><br><span class="line">                <span class="hljs-comment">//比较锁的时间，如果不一致则可能是其他锁已经修改了值并获取</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (oldValue != <span class="hljs-keyword">null</span> &amp;&amp; oldValue.equals(currentValue)) &#123;</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"get redis lock timeout,key=["</span> + key + <span class="hljs-string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title">unlock</span><span class="hljs-params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (StringUtils.isBlank(key)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-comment">//redis的del命令</span></span><br><span class="line">        del(key);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="hljs-string">"redis unlock exception, key=&#123;&#125;"</span>, key, e);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p> 项目中代码存在的问题</p><ol><li>过期时间调用的是: System.nanoTime(),这就需要客户端的时间必须同步</li><li>getAndSet 虽然只有一个客户端可以获取锁，但是会覆盖过期时间</li><li>锁不具备拥有者标识，相当于所有客户端都拥有相同的key，且对应的value区分不出客户端，即任何客户端都可以解锁。举例：<strong>客户端A加锁，一段时间之后客户端A解锁，在执行删除key之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了。</strong></li></ol></blockquote><blockquote><p>加锁过程优化</p><ol><li>加锁原理：基于redis的set命令，value为每个客户端唯一的id，10000为过期时间，相当于setex和setnx两条命令的整合<img src="/2019/04/03/redis/redis001.png" alt></li><li>解锁原理(摘抄网上一段方法)<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令,保证了其原子性</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">del</span><span class="hljs-params">(Jedis jedis, String key, String requestId)</span> </span>&#123;</span><br><span class="line">        String script = <span class="hljs-string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line">        <span class="hljs-keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近项目当中需要处理分布式系统中的并发问题，自然地想到了引入分布式锁，本文旨在讲述用redis简单的实现分布式锁，对于复杂的类似于redis集群问题、为什么不用zk等，自己也在学习，希望可以以后有机会分享&lt;/p&gt;
&lt;h2 id=&quot;分布式锁的可靠性保证&quot;&gt;&lt;a href=&quot;#分布式锁的可靠性保证&quot; class=&quot;headerlink&quot; title=&quot;分布式锁的可靠性保证&quot;&gt;&lt;/a&gt;分布式锁的可靠性保证&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在过期时间内，只有一个客户端持有锁&lt;/li&gt;
&lt;li&gt;在客户端持有锁期间短暂崩溃或者redis发生短暂崩溃时，不会有死锁状态&lt;/li&gt;
&lt;li&gt;加锁和解锁必须是同一客户端，加锁和解锁必须是同一个客户端&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="redis" scheme="https://stonezpl.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>linux 常用命令(持续更新)</title>
    <link href="https://stonezpl.github.io/2019/04/01/linux/"/>
    <id>https://stonezpl.github.io/2019/04/01/linux/</id>
    <published>2019-04-01T12:48:19.000Z</published>
    <updated>2019-04-03T14:28:49.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看磁盘空间大小"><a href="#查看磁盘空间大小" class="headerlink" title="查看磁盘空间大小"></a>查看磁盘空间大小</h1><ol><li>查看磁盘空间大小: df -h<img src="/2019/04/01/linux/linux001.png" alt></li><li>查看指定目录大小: du -sh &lt;目录名&gt;<img src="/2019/04/01/linux/linux002.png" alt><a id="more"></a></li><li>du -h [目录名]：查看指定文件夹下的所有文件大小（包含子文件夹)</li><li>对文件大小进行排序(进入当前目录下)：<img src="/2019/04/01/linux/linux003.png" alt></li></ol><h1 id="文本查询相关"><a href="#文本查询相关" class="headerlink" title="文本查询相关"></a>文本查询相关</h1><ol><li>统计某个词出现频率<img src="/2019/04/01/linux/linux004.png" alt></li><li>统计单词次数并按次数排序(每一行为一个单词):<img src="/2019/04/01/linux/linux005.png" alt></li><li>按照分隔符分词，然后排序，去重：<img src="/2019/04/01/linux/linux006.png" alt></li></ol><h1 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h1><ol><li>查看端口占用进程和进程占用端口<img src="/2019/04/01/linux/linux007.png" alt></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;查看磁盘空间大小&quot;&gt;&lt;a href=&quot;#查看磁盘空间大小&quot; class=&quot;headerlink&quot; title=&quot;查看磁盘空间大小&quot;&gt;&lt;/a&gt;查看磁盘空间大小&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;查看磁盘空间大小: df -h&lt;img src=&quot;/2019/04/01/linux/linux001.png&quot; alt&gt;&lt;/li&gt;
&lt;li&gt;查看指定目录大小: du -sh &amp;lt;目录名&amp;gt;&lt;img src=&quot;/2019/04/01/linux/linux002.png&quot; alt&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="linux" scheme="https://stonezpl.github.io/categories/linux/"/>
    
    
  </entry>
  
</feed>
