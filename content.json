{"pages":[{"title":"张珮磊想静静","text":"简介本博客主要维护人张珮磊(别问我静静是谁，我只是想而已)，毕业于重庆邮电大学计算机专业，代码写多了，总会感到技术有种小小的无奈，但希望技术能够给生活带去一点点美好 联系方式微信: zplxjj","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"#ddd","link":"/tags/index.html"}],"posts":[{"title":"linux 常用命令(持续更新)","text":"查看磁盘空间大小 查看磁盘空间大小: df -h 查看指定目录大小: du -sh &lt;目录名&gt; du -h [目录名]：查看指定文件夹下的所有文件大小（包含子文件夹) 对文件大小进行排序(进入当前目录下)： 文本查询相关 统计某个词出现频率 统计单词次数并按次数排序(每一行为一个单词): 按照分隔符分词，然后排序，去重： 查看端口占用 查看端口占用进程和进程占用端口","link":"/2019/04/01/linux/"},{"title":"redis分布式锁——简单实现","text":"前言最近项目当中需要处理分布式系统中的并发问题，自然地想到了引入分布式锁，本文旨在讲述用redis简单的实现分布式锁，对于复杂的类似于redis集群问题、为什么不用zk等，自己也在学习，希望可以以后有机会分享 分布式锁的可靠性保证 在过期时间内，只有一个客户端持有锁 在客户端持有锁期间短暂崩溃或者redis发生短暂崩溃时，不会有死锁状态 加锁和解锁必须是同一客户端，加锁和解锁必须是同一个客户端 代码实现 项目当中的实现12345678910111213141516171819202122232425262728293031323334353637383940414243public static Boolean lock(String key) { Long nowTIme = System.nanoTime(); //TIMEOUT_NANO：超时时间 while (TIMEOUT_NANO &gt; System.nanoTime() - nowTIme) { long expires = System.nanoTime() + EXPIRE_NANO; //锁到期时间 String expiresStr = String.valueOf(expires); //putIfAbsent: setnx命令 if (putIfAbsent(key, expiresStr)) { return true; } //当redis存在这个key的时候，取出这个key，判断是否超时 String currentValue = get(key); //判断锁是否已经过期，过期则重新设置并获取 if (currentValue != null) { if(Long.parseLong(currentValue) &lt; System.nanoTime() - EXPIRE_NANO){ //设置锁并返回旧值：getSet String oldValue = getAndSet(key, expiresStr); //比较锁的时间，如果不一致则可能是其他锁已经修改了值并获取 if (oldValue != null &amp;&amp; oldValue.equals(currentValue)) { return true; } }else { return false; } } } throw new RuntimeException(\"get redis lock timeout,key=[\" + key + \"]\");}public static Boolean unlock(String key) { if (StringUtils.isBlank(key)) { return false; } try { //redis的del命令 del(key); } catch (Exception e) { log.error(\"redis unlock exception, key={}\", key, e); return false; } return true;} 项目中代码存在的问题 过期时间调用的是: System.nanoTime(),这就需要客户端的时间必须同步 getAndSet 虽然只有一个客户端可以获取锁，但是会覆盖过期时间 锁不具备拥有者标识，相当于所有客户端都拥有相同的key，且对应的value区分不出客户端，即任何客户端都可以解锁。举例：客户端A加锁，一段时间之后客户端A解锁，在执行删除key之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了。 加锁过程优化 加锁原理：基于redis的set命令，value为每个客户端唯一的id，10000为过期时间，相当于setex和setnx两条命令的整合 解锁原理(摘抄网上一段方法)123456789//eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令,保证了其原子性public static boolean del(Jedis jedis, String key, String requestId) { String script = \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\"; Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId)); if (RELEASE_SUCCESS.equals(result)) { return true; } return false; }","link":"/2019/04/03/redis/"}],"tags":[],"categories":[{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"redis","slug":"redis","link":"/categories/redis/"}]}