{"pages":[{"title":"关于作者","text":"简介本博客主要维护人张珮磊(别问我静静是谁，我只是想而已)，毕业于重庆邮电大学计算机专业 初衷代码写多了，总会感到技术有种小小的无奈，但希望技术能够给生活带去一点点美好 联系方式微信: zplxjj 公众号:stonezplxjj","link":"/about/index.html"},{"title":"tags","text":"#ddd","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"linux 常用命令(持续更新)","text":"查看磁盘空间大小 查看磁盘空间大小: df -h 查看指定目录大小: du -sh &lt;目录名&gt; du -h [目录名]：查看指定文件夹下的所有文件大小（包含子文件夹) 对文件大小进行排序(进入当前目录下)： 文本查询相关 统计某个词出现频率 统计单词次数并按次数排序(每一行为一个单词): 按照分隔符分词，然后排序，去重： 查看端口占用 查看端口占用进程和进程占用端口","link":"/2019/04/01/linux/"},{"title":"redis分布式锁——简单实现","text":"前言最近项目当中需要处理分布式系统中的并发问题，自然地想到了引入分布式锁，本文旨在讲述用redis简单的实现分布式锁，对于复杂的类似于redis集群问题、为什么不用zk等，自己也在学习，希望可以以后有机会分享 分布式锁的可靠性保证 在过期时间内，只有一个客户端持有锁 在客户端持有锁期间短暂崩溃或者redis发生短暂崩溃时，不会有死锁状态 加锁和解锁必须是同一客户端，加锁和解锁必须是同一个客户端 代码实现 项目当中的实现12345678910111213141516171819202122232425262728293031323334353637383940414243public static Boolean lock(String key) { Long nowTIme = System.nanoTime(); //TIMEOUT_NANO：超时时间 while (TIMEOUT_NANO &gt; System.nanoTime() - nowTIme) { long expires = System.nanoTime() + EXPIRE_NANO; //锁到期时间 String expiresStr = String.valueOf(expires); //putIfAbsent: setnx命令 if (putIfAbsent(key, expiresStr)) { return true; } //当redis存在这个key的时候，取出这个key，判断是否超时 String currentValue = get(key); //判断锁是否已经过期，过期则重新设置并获取 if (currentValue != null) { if(Long.parseLong(currentValue) &lt; System.nanoTime() - EXPIRE_NANO){ //设置锁并返回旧值：getSet String oldValue = getAndSet(key, expiresStr); //比较锁的时间，如果不一致则可能是其他锁已经修改了值并获取 if (oldValue != null &amp;&amp; oldValue.equals(currentValue)) { return true; } }else { return false; } } } throw new RuntimeException(\"get redis lock timeout,key=[\" + key + \"]\");}public static Boolean unlock(String key) { if (StringUtils.isBlank(key)) { return false; } try { //redis的del命令 del(key); } catch (Exception e) { log.error(\"redis unlock exception, key={}\", key, e); return false; } return true;} 项目中代码存在的问题 过期时间调用的是: System.nanoTime(),这就需要客户端的时间必须同步 getAndSet 虽然只有一个客户端可以获取锁，但是会覆盖过期时间 锁不具备拥有者标识，相当于所有客户端都拥有相同的key，且对应的value区分不出客户端，即任何客户端都可以解锁。举例：客户端A加锁，一段时间之后客户端A解锁，在执行删除key之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了。 加锁过程优化 加锁原理：基于redis的set命令，value为每个客户端唯一的id，10000为过期时间，相当于setex和setnx两条命令的整合 解锁原理(摘抄网上一段方法)123456789//eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令,保证了其原子性public static boolean del(Jedis jedis, String key, String requestId) { String script = \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\"; Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId)); if (RELEASE_SUCCESS.equals(result)) { return true; } return false; }","link":"/2019/04/03/redis/"},{"title":"springboot(一)——搭建属于自己的springboot项目","text":"idea使用spring Initalizr 快速构建spring boot 点击新建项目,选择如图所示 点击next后 点击next，之后按照图中所示选择 选择路径 点击完成，如图所示，删除自己不想要的，项目构建完成 构建一个controller，启动项目就可以看到返回结果了 在自己的服务器搭建自己的springboot项目使用idea向远程服务传递项目 设置idea 配置相关信息 上传到指定机器 配置启动脚本，基于java -jar命令 start.sh 12#!/bin/bashnohup java -jar target/zplxjj.jar &amp; stop.sh 12345678910#!/bin/bashPID=$(ps -ef | grep target/zplxjj.jar | grep -v grep | awk &apos;{ print $2 }&apos;)if [ -z &quot;$PID&quot; ]then echo Application is already stoppedelse echo kill $PID kill $PIDfi~ run.sh 12345#!/bin/bashecho stop applicationsource stop.shecho start applicationsource start.sh 启动自己的项目只需要执行run.sh就行，一个自己的spring boot就搭建起来了 logback配置实际项目中，我们希望日志可以记录在服务器上面，这边用的是logback，是springboot自带的，我这边集成方式是加入logback-spring.xml文件，加入后启动项目即可，文件内容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;!--用来定义变量值的标签--&gt; &lt;property name=\"LOG_HOME\" value=\"./logs\"/&gt; &lt;property name=\"encoding\" value=\"UTF-8\"/&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度；%M:%L是方法和行号；%msg是日志消息；%n是换行符--&gt; &lt;property name=\"normal-pattern\" value=\"%d{yyyy-MM-dd/HH:mm:ss.SSS}|%X{localIp}|%X{requestId}|%X{requestSeq}|%X{country}|%X{deviceType}|%X{deviceId}|%X{userId}|^_^|[%t] %-5level %logger{50} %line - %m%n\"/&gt; &lt;property name=\"plain-pattern\" value=\"%d{yyyy-MM-dd.HH:mm:ss} %msg%n\"/&gt; &lt;!-- 按照每天生成日志文件 --&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!--日志文件输出的文件名--&gt; &lt;file&gt;${LOG_HOME}/zplxjj.log&lt;/file&gt; &lt;Append&gt;true&lt;/Append&gt; &lt;prudent&gt;false&lt;/prudent&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;pattern&gt;${normal-pattern}&lt;/pattern&gt; &lt;charset&gt;${encoding}&lt;/charset&gt; &lt;/encoder&gt; &lt;!--按时间分割--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;${LOG_HOME}/zplxjj.log.%d{yyyy-MM-dd}.%i&lt;/fileNamePattern&gt; &lt;maxFileSize&gt;128MB&lt;/maxFileSize&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;totalSizeCap&gt;32GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;!--控制台输出--&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;${normal-pattern}&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- log file error --&gt; &lt;appender name=\"ERROR\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt; &lt;file&gt;${LOG_HOME}/zplxjj-error.log&lt;/file&gt; &lt;prudent&gt;false&lt;/prudent&gt; &lt;Append&gt;true&lt;/Append&gt; &lt;encoder&gt; &lt;pattern&gt;${normal-pattern}&lt;/pattern&gt; &lt;charset&gt;${encoding}&lt;/charset&gt; &lt;/encoder&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;${LOG_HOME}/zplxjj-error.log.%d{yyyy-MM-dd}.%i&lt;/fileNamePattern&gt; &lt;maxFileSize&gt;128MB&lt;/maxFileSize&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;totalSizeCap&gt;32GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"STDOUT\"/&gt; &lt;appender-ref ref=\"FILE\"/&gt; &lt;appender-ref ref=\"ERROR\"/&gt; &lt;/root&gt;&lt;/configuration&gt; 效果如图：","link":"/2019/04/16/springboot/"},{"title":"springboot(四)——@EnableConfigurationProperties是如何起作用的你知道吗","text":"前言用springboot开发的过程中，我们会用到@ConfigurationProperties注解，主要是用来把properties或者yml配置文件转化为bean来使用的，而@EnableConfigurationProperties注解的作用是@ConfigurationProperties注解生效。如果只配置@ConfigurationProperties注解，在IOC容器中是获取不到properties配置文件转化的bean的，当然在@ConfigurationProperties加入注解的类上加@Component也可以使交于springboot管理。 举个栗子 第一步：创建一个类TestConfigurationProperties123456789101112@ConfigurationProperties(prefix = \"properties\")public class TestConfigurationProperties { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; }} 注意：得加上set和get方法第二步：创建TestAutoConfiguration类1234567891011121314151617@Configuration@EnableConfigurationProperties(TestConfigurationProperties.class)public class TestAutoConfiguration { private TestConfigurationProperties testConfigurationProperties; public TestAutoConfiguration(TestConfigurationProperties testConfigurationProperties) { this.testConfigurationProperties = testConfigurationProperties; } @Bean public User user(){ User user = new User(); user.setName(testConfigurationProperties.getName()); return user; }} 注意：得创建一个有参构造方法第三步：配置文件加入属性1properties.name=test 第四步：跑一下，打印出User这个类1234567891011121314151617@RestController@RequestMapping(\"/api/test\")@Slf4jpublic class TestController { @Autowired TestConfigurationProperties testConfigurationProperties; @Autowired User user; @RequestMapping(value = \"/testConfigurationProperties\") public String testConfigurationProperties() { log.info(\"test testConfigurationProperties.............{}\", testConfigurationProperties.getName()); log.info(\"user:{}\", user); return \"SUCCESS\"; }} 控制台输出：122019-04-21/16:11:36.638||||||||^_^|[http-nio-8088-exec-1] INFO com.stone.zplxjj.controller.TestController 37 - test testConfigurationProperties.............test2019-04-21/16:11:36.639||||||||^_^|[http-nio-8088-exec-1] INFO com.stone.zplxjj.controller.TestController 38 - user:User(id=null, name=test) @EnableConfigurationProperties是怎么加载的通过查看@EnableConfigurationProperties的注解：1234567891011121314@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(EnableConfigurationPropertiesImportSelector.class)public @interface EnableConfigurationProperties { /** * Convenient way to quickly register {@link ConfigurationProperties} annotated beans * with Spring. Standard Spring Beans will also be scanned regardless of this value. * @return {@link ConfigurationProperties} annotated beans to register */ Class&lt;?&gt;[] value() default {};} 通过分析自动配置可以知道，肯定是这个类EnableConfigurationPropertiesImportSelector起的作用：12345678private static final String[] IMPORTS = { ConfigurationPropertiesBeanRegistrar.class.getName(), ConfigurationPropertiesBindingPostProcessorRegistrar.class.getName() }; @Override public String[] selectImports(AnnotationMetadata metadata) { return IMPORTS; } selectImports方法返回了这两个类：ConfigurationPropertiesBeanRegistrar和ConfigurationPropertiesBindingPostProcessorRegistrar，是何时加载的，我们只需要看这个类ConfigurationPropertiesBeanRegistrar即可：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public static class ConfigurationPropertiesBeanRegistrar implements ImportBeanDefinitionRegistrar { @Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) { getTypes(metadata).forEach((type) -&gt; register(registry, (ConfigurableListableBeanFactory) registry, type)); } //找到加入这个注解@EnableConfigurationProperties里面的value值，其实就是类class private List&lt;Class&lt;?&gt;&gt; getTypes(AnnotationMetadata metadata) { MultiValueMap&lt;String, Object&gt; attributes = metadata .getAllAnnotationAttributes( EnableConfigurationProperties.class.getName(), false); return collectClasses((attributes != null) ? attributes.get(\"value\") : Collections.emptyList()); } private List&lt;Class&lt;?&gt;&gt; collectClasses(List&lt;?&gt; values) { return values.stream().flatMap((value) -&gt; Arrays.stream((Object[]) value)) .map((o) -&gt; (Class&lt;?&gt;) o).filter((type) -&gt; void.class != type) .collect(Collectors.toList()); } //注册方法：根据找到的类名name和type，将加入注解@ConfigurationProperties的类加入spring容器里面 private void register(BeanDefinitionRegistry registry, ConfigurableListableBeanFactory beanFactory, Class&lt;?&gt; type) { String name = getName(type); if (!containsBeanDefinition(beanFactory, name)) { registerBeanDefinition(registry, name, type); } } //找到加入注解@ConfigurationProperties的类的名称，加入一定格式的拼接 private String getName(Class&lt;?&gt; type) { ConfigurationProperties annotation = AnnotationUtils.findAnnotation(type, ConfigurationProperties.class); String prefix = (annotation != null) ? annotation.prefix() : \"\"; return (StringUtils.hasText(prefix) ? prefix + \"-\" + type.getName() : type.getName()); } private boolean containsBeanDefinition( ConfigurableListableBeanFactory beanFactory, String name) { if (beanFactory.containsBeanDefinition(name)) { return true; } BeanFactory parent = beanFactory.getParentBeanFactory(); if (parent instanceof ConfigurableListableBeanFactory) { return containsBeanDefinition((ConfigurableListableBeanFactory) parent, name); } return false; } private void registerBeanDefinition(BeanDefinitionRegistry registry, String name, Class&lt;?&gt; type) { assertHasAnnotation(type); GenericBeanDefinition definition = new GenericBeanDefinition(); definition.setBeanClass(type); registry.registerBeanDefinition(name, definition); } private void assertHasAnnotation(Class&lt;?&gt; type) { Assert.notNull( AnnotationUtils.findAnnotation(type, ConfigurationProperties.class), () -&gt; \"No \" + ConfigurationProperties.class.getSimpleName() + \" annotation found on '\" + type.getName() + \"'.\"); } } 结语另外还有这个类：ConfigurationPropertiesBindingPostProcessorRegistrar，刚刚没有分析，看了下源码，其实他做的事情就是将配置文件当中的属性值赋予到加了@ConfigurationProperties的注解的类的属性上，具体就不分析了，有兴趣自己可以阅读，入口知道了，就简单了","link":"/2019/04/24/springboot-2/"},{"title":"与go邂逅(二)——基本程序结构","text":"前言学习一门语言的时候，难免从最简单的程序结构学起，这些东西在掌握了一门别的开发语言的情况(如大名鼎鼎的java)，就会显得如鱼得水了，下面会把我学习一些简单例子分享出来。 基本程序结构快速为一些变量赋值1234567891011const ( NUM1 = 1 + iota NUM2 NUM3 NUM4)//输出结果：1，2，4，8func TestPrint(t *testing.T) { t.Log(NUM1, NUM2, NUM3, NUM4)} 快速的实现一些数值交换12345678910//数值交换func TestExchange(t *testing.T) {//也可以这样定义变量：var aa int = 1 a := 1 b := 2 t.Log(a, b) //交换数值 b, a = a, b t.Log(a, b)} 类型转换123456789101112//给类型命名type typeInt int64func TestInt(t *testing.T) { var a int64 = 2 var b int32 = 3 //类型不可转 //a = b var c = typeInt(3) t.Log(a, b, c)} 实现斐波拉切数列的两种方式123456789101112131415161718192021222324//斐波拉切func TestFibList(t *testing.T) { var a int = 1 var b int = 1 t.Log(a) for i := 0; i &lt; 5; i++ { t.Log(b) tmp := a + b a = b b = tmp }}//斐波拉切 递归func TestFibRecursion(t *testing.T) { t.Log(FibRecursion(5))}func FibRecursion(i int) (result int) { if i == 1 || i == 2 { return 1 } return FibRecursion(i-1) + FibRecursion(i-2)} 数组比较，和java不同，不是比较指针，可以比较值的12345678//数组比较func TestCompareArray(t *testing.T) { a := [...]int{1, 2, 3, 4} b := [...]int{1, 2, 2, 4} c := [...]int{1, 2, 3, 4} t.Log(a == b) //false t.Log(a == c) //true} go也是有指针的，但是没有细看，只是写个例子看下结果1234567func TestPoint(t *testing.T) { var a int64 = 1 var aPtr = &amp;a t.Log(a, aPtr)// 1 0xc420018230 //打印类: int64 *int64 t.Logf(\"%T %T\", a, aPtr)} string的默认值12345func TestString(t *testing.T) { //默认值是\"\" 不是java的那种null var str string t.Log(\"+\" + str + \"+\")//输出++} for循环12345678910111213141516171819202122232425//for循环 go当中原来没有whilefunc TestFor(t *testing.T) { n := 5 for n &gt; 0 { t.Log(n) n-- }}//for循环实现冒泡排序func TestForSort(t *testing.T) { a := [...]int{3, 5, 2, 6, 4, 8, 2, 9,1,23,2,34,4,55,11} for i := 0; i &lt; len(a)-1; i++ { for j := 0; j &lt; len(a)-i-1; j++ { if a[j] &gt; a[j+1] { tmp := a[j] a[j] = a[j+1] a[j+1] = tmp } } } t.Log(a)//[1 2 2 2 3 4 4 5 6 8 9 11 23 34 55]} go当中的条件判断，写起来还是很爽的1234567891011121314151617181920212223242526272829//比较func TestCondition(t *testing.T){ //可以条件结果赋值给变量 if a:=3&gt;2;a{ t.Log(\"3&gt;2\") } // GOOS is the running program's operating system target: // one of darwin, freebsd, linux, and so on. switch runtime.GOOS{ //自带break case \"darwin\": t.Log(\"darwin\") case \"freebsd\": t.Log(\"freebsd\") case \"linux\": t.Log(\"linux\") default: t.Log(\"default\") } switch { case 4&gt;2: t.Log(\"4&gt;2\") case 4&lt;2: t.Log(\"4&lt;2\") }}","link":"/2019/04/26/与go邂逅/"},{"title":"springboot(五)——springboot中的拦截器和过滤器小结","text":"前言关于过滤器Filter和拦截器Interceptor，大家都不会陌生，从一开始的servelet，到springmvc，再到现在的springboot，都有接触到，记得刚接触的时候，会容易弄混淆，想写这篇文章做个小的总结 拦截器和过滤器的异同 相同点 都是aop编程思想的体现，可以在程序执行前后做一些操作，如权限操作，日志记录等 不同点： Filter是Servlet规范中定义的，拦截器是Spring框架中的 触发时机不一样，过滤器是在请求进入容器后，但请求进入servlet之前进行预处理的 拦截器可以获取IOC容器中的各个bean，而过滤器就不行，拦截器归Spring管理 Springboot实现过滤器和拦截器第一步：定义Filter12345678910@Slf4jpublic class TestFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { log.info(\"TestFilter filter。。。。。。。。\"); filterChain.doFilter(servletRequest, servletResponse); }} 第二步：注入springboot容器当中1234567891011121314151617@Configurationpublic class FilterConfig { @Bean Filter testFilter(){ return new TestFilter(); } @Bean public FilterRegistrationBean&lt;TestFilter&gt; filterRegistrationBean1(){ FilterRegistrationBean&lt;TestFilter&gt; filterRegistrationBean=new FilterRegistrationBean&lt;&gt;(); filterRegistrationBean.setFilter((TestFilter) testFilter()); filterRegistrationBean.addUrlPatterns(\"/*\"); //filterRegistrationBean.setOrder();多个filter的时候order的数值越小 则优先级越高 return filterRegistrationBean; }} 第三步：定义拦截器123456789101112131415161718192021@Slf4j@Service(value = \"testInterceptor\")public class TestInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { log.info(\"TestInterceptor preHandle....\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception { log.info(\"TestInterceptor postHandle....\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception { log.info(\"TestInterceptor afterCompletion....\"); }} 第四步：加入springboot容器123456789101112@Configurationpublic class InterceptorConfig implements WebMvcConfigurer { @Autowired TestInterceptor testInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(testInterceptor) .addPathPatterns(\"/api/**\"); }} 注意：这边用的springboot是2.0.x，采取的是直接实现WebMvcConfigurer，因为WebMvcConfigurerAdapter被标识了@Deprecated，就没有继承WebMvcConfigurerAdapter了123456/** @deprecated */@Deprecatedpublic abstract class WebMvcConfigurerAdapter implements WebMvcConfigurer { public WebMvcConfigurerAdapter() { }} 第五步：还是启动之前的controller12345678910@RestController@RequestMapping(\"/api/test\")@Slf4jpublic class TestController { @RequestMapping(value = \"/hello\") public String test() { log.info(\"test hello.............\"); return \"SUCCESS\"; } 看到打印结果如下12342019-04-27/12:01:04.603||||||||^_^|[http-nio-8088-exec-1] INFO com.stone.zplxjj.filter.TestFilter 22 - TestFilter filter。。。。。。。。2019-04-27/12:01:04.612||||||||^_^|[http-nio-8088-exec-1] INFO com.stone.zplxjj.interceptor.TestInterceptor 26 - TestInterceptor preHandle....2019-04-27/12:01:04.634||||||||^_^|[http-nio-8088-exec-1] INFO com.stone.zplxjj.interceptor.TestInterceptor 32 - TestInterceptor postHandle....2019-04-27/12:01:04.634||||||||^_^|[http-nio-8088-exec-1] INFO com.stone.zplxjj.interceptor.TestInterceptor 37 - TestInterceptor afterCompletion.... 小结过滤器的实现基于回调函数。而拦截器（代理模式）的实现基于反射，代理又分静态代理和动态代理，动态代理是拦截器的简单实现。那何时使用拦截器？何时使用过滤器？ 如果是非spring项目，那么拦截器不能用，只能使用过滤器，这里说的拦截器是基于spring的拦截器。 如果是处理controller前后，既可以使用拦截器也可以使用过滤器，如果都使用了，注意前后顺序。 如果是处理dispaterServlet前后，只能使用过滤器。","link":"/2019/04/27/springboot/"},{"title":"与go邂逅(一)——go环境搭建和Helloworld(开发工具：GOLAND)","text":"环境搭建学习语言，搭建环境必不可少，虽然网上教程也很多，但是我也记录下我的mac上面环境配置 从网上下载安装文件，下载地址：https://golang.google.cn/dl/ mac 有自带的pkg文件，但是我选择的是go1.12.4.linux-amd64.tar.gz 下载下来解压即可，会有个命名为go的文件夹 配置环境变量，修改/etc/profile(全局的)或者.bash_profile(私有的)即可，配置完执行下source，我的配置如下：123export GOROOT=$HOME/go_dev/goexport PATH=$PATH:$GOROOT/binexport GOPATH=$HOME/code/personal/code/go_project 配置完，执行go version查看安装是否成功 开发工具没有做过比较，只是之前写java的时候用的idea，所以用了goland，它们都是一家公司的，挺好用 创建项目 新建一个项目，配置好路径2如图所以创建三个目录创建以.go为结尾的文件，命名随意写一个hello world 执行下:1234567package mainimport \"fmt\"func main(){ fmt.Println(\"Hello World\")} 写到这里，其实go语言环境就跑通了，其实我们在写java项目的时候，都会有单元测试类，其实go当中也有，只要遵循一定的写法就可以了，我们首先见一个目录：文件名称需要以_test结尾，代码如下：12345678package testimport \"testing\"//方法名以Test开头，加入参数，*testing.T tfunc TestPrint(t *testing.T) { t.Log(\"test hello world\")}","link":"/2019/04/25/与go邂逅/"},{"title":"springboot(三)——application.properties和application.yml是何时解析的","text":"前言用过的springboot的小伙伴都知道springboot不需要再像springmvc引入那么多的配置文件，只需要加入application.properties或者application.yml即可，比如在上一篇文章讲到数据库的配置，只需要在文件引入如下的配置即可：1234spring.datasource.url=jdbc:mysql://127.0.0.1:3306/zplxjj?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=@ZPLxjj12345spring.datasource.driver-class-name=com.mysql.jdbc.Driver 下面简单介绍下springboot在启动的时候是在何时读取的properties和yml文件的内容的 实现一个简单的自定义监听器第一步：定义一个event，继承ApplicationEvent123456public class CustomerApplicationEvent extends ApplicationEvent { public CustomerApplicationEvent(Object source) { super(source); System.out.println(\"CustomerApplicationEvent constructor...\"); }} 第二步：定义一个listener12345678@Componentpublic class CustomerApplicationListener implements ApplicationListener&lt;CustomerApplicationEvent&gt; { @Override public void onApplicationEvent(CustomerApplicationEvent customerApplicationEvent) { System.out.println(\"customerApplicationEvent:\"+customerApplicationEvent.getClass().getName()); }} 第三步：注册监听器12345678910@SpringBootApplicationpublic class Application { public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(Application.class, args); // 注册 CustomerApplicationListener 事件监听器 context.addApplicationListener(new CustomerApplicationListener()); // 发布 CustomerApplicationEvent 事件 context.publishEvent(new CustomerApplicationEvent(new Object())); }} 启动项目后，会发现控制台输出了：12CustomerApplicationEvent constructor...customerApplicationEvent:com.stone.zplxjj.event.CustomerApplicationEvent springboot自带的事件 ApplicationStartingEvent：应用启动事件，在调用 SpringApplication.run() 方法之前，可以从中获取到 SpringApplication 对象，进行一些启动前设置。 ApplicationEnvironmentPreparedEvent：Environment准备完成事件，此时可以从中获取到 Environment 对象并对其中的配置项进行查看或者修改。 ApplicationPreparedEvent：ApplicationContext准备完成事件，接下来 Spring 就能够向容器中加载 Bean 了 。 ApplicationReadyEvent：应用准备完成事件，预示着应用可以接收和处理请求了。 ApplicationFailedEvent：应用启动失败事件，可以从中捕获到启动失败的异常信息进行相应处理，例如：添加虚拟机对应的钩子进行资源的回收与释放。 读取配置代码入口：ApplicationEnvironmentPreparedEvent和ConfigFileApplicationListener加载配置文件需要用到ConfigFileApplicationListener，其代码如下：12345678910@Overridepublic void onApplicationEvent(ApplicationEvent event) { if (event instanceof ApplicationEnvironmentPreparedEvent) { onApplicationEnvironmentPreparedEvent( (ApplicationEnvironmentPreparedEvent) event); } if (event instanceof ApplicationPreparedEvent) { onApplicationPreparedEvent(event); }} 进入方法：onApplicationEnvironmentPreparedEvent12345678910private void onApplicationEnvironmentPreparedEvent( ApplicationEnvironmentPreparedEvent event) { List&lt;EnvironmentPostProcessor&gt; postProcessors = loadPostProcessors(); postProcessors.add(this); AnnotationAwareOrderComparator.sort(postProcessors); for (EnvironmentPostProcessor postProcessor : postProcessors) { postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication()); }} 进入postProcessor.postProcessEnvironment：123456 //类：ConfigFileApplicationListener@Overridepublic void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) { addPropertySources(environment, application.getResourceLoader());} 进入addPropertySources1234567protected void addPropertySources(ConfigurableEnvironment environment, ResourceLoader resourceLoader) { //将随机方法放入到PropertySources中 RandomValuePropertySource.addToEnvironment(environment); //load加载 new Loader(environment, resourceLoader).load();} 进入load方法：1234567891011121314151617181920public void load() { this.profiles = new LinkedList&lt;&gt;(); this.processedProfiles = new LinkedList&lt;&gt;(); this.activatedProfiles = false; this.loaded = new LinkedHashMap&lt;&gt;(); initializeProfiles(); while (!this.profiles.isEmpty()) { Profile profile = this.profiles.poll(); if (profile != null &amp;&amp; !profile.isDefaultProfile()) { addProfileToEnvironment(profile.getName()); } load(profile, this::getPositiveProfileFilter, addToLoaded(MutablePropertySources::addLast, false)); this.processedProfiles.add(profile); } resetEnvironmentProfiles(this.processedProfiles); load(null, this::getNegativeProfileFilter, addToLoaded(MutablePropertySources::addFirst, true)); addLoadedPropertySources();} 进入字方法load123456789 private void load(Profile profile, DocumentFilterFactory filterFactory, DocumentConsumer consumer) { getSearchLocations().forEach((location) -&gt; { boolean isFolder = location.endsWith(\"/\"); Set&lt;String&gt; names = isFolder ? getSearchNames() : NO_SEARCH_NAMES; names.forEach( (name) -&gt; load(location, name, profile, filterFactory, consumer)); });} getSearchLocations():首先看CONFIG_LOCATION_PROPERTY，是否存在配置，无则走默认配置路径DEFAULT_SEARCH_LOCATIONS 1234567/** * The \"config location\" property name. */public static final String CONFIG_LOCATION_PROPERTY = \"spring.config.location\";// Note the order is from least to most specific (last one wins)private static final String DEFAULT_SEARCH_LOCATIONS = \"classpath:/,classpath:/config/,file:./,file:./config/\"; getSearchNames():首先看CONFIG_NAME_PROPERTY(spring.config.name)配置，否则走DEFAULT_NAMES(application) spring.config.name说明：假如你不喜欢“application.properties”这个默认文件名，你可以重新设定：spring.config.name属性直接指定属性文件名称，spring.config.location属性指定明确路径，但是要注意不能写在application.properties文件里，这样会不起作用，可以写在java -jar xxx.jar –spring.config.name=custom.properties,还可以通过环境变量等方式,yml文件也可以这样 真正加载配置文件的方法：123456789101112131415161718192021private void load(String location, String name, Profile profile, DocumentFilterFactory filterFactory, DocumentConsumer consumer) { if (!StringUtils.hasText(name)) { for (PropertySourceLoader loader : this.propertySourceLoaders) { if (canLoadFileExtension(loader, location)) { load(loader, location, profile, filterFactory.getDocumentFilter(profile), consumer); return; } } } Set&lt;String&gt; processed = new HashSet&lt;&gt;(); for (PropertySourceLoader loader : this.propertySourceLoaders) { for (String fileExtension : loader.getFileExtensions()) { if (processed.add(fileExtension)) { loadForFileExtension(loader, location + name, \".\" + fileExtension, profile, filterFactory, consumer); } } }} loader.getFileExtensions():获取所有支持的文件后缀,loader初始化如下：1234Loader(ConfigurableEnvironment environment, ResourceLoader resourceLoader) { this.propertySourceLoaders = SpringFactoriesLoader.loadFactories( PropertySourceLoader.class, getClass().getClassLoader());} 通过加载jar:spring-boot-2.1.4.RELEASE.jar:META-INF/spring.factories文件下对应内容：1234# PropertySource Loadersorg.springframework.boot.env.PropertySourceLoader=\\org.springframework.boot.env.PropertiesPropertySourceLoader,\\org.springframework.boot.env.YamlPropertySourceLoader 从这里我们可以看到，通过PropertiesPropertySourceLoader和YamlPropertySourceLoader加载配置文件，具体源码没有细看了，有兴趣自行阅读吧 加载完配置文件，调用方法：addLoadedPropertySources() 结语至此，springboot加载properties和yml的入口就分析到这里了，细节上肯定不能面面俱到，但是入口知道了，后面就好分析了","link":"/2019/04/24/springboot-1/"},{"title":"springboot(二)——springboot自动配置解析","text":"前言用过springboot的同学肯定很熟悉，它其中有个重要的特性，就是自动配置(平时习惯的一些设置的配置作为默认配置)。springboot提倡无XML配置文件的理念，使用springboot生成的应用完全不会生成任何配置代码与XML配置文件。下面先看一个springboot集成mybatis的例子。第一步： 引入pom文件12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt; 第二步： 因为我使用的xml配置文件去使用mybatis，在application.properties文件加入如下配置：12345678#指定mapper文件位置mybatis.mapper-locations=classpath:mapper/*.xml#数据源信息spring.datasource.url=jdbc:mysql://127.0.0.1:3306/zplxjj?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8spring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driver 第三步： 加入实体类、dao、mapper文件第四步：启动类上面加入注解1234567@SpringBootApplication@MapperScan(\"com.stone.zplxjj.dao\")public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }} 第五步：至此，配置完成，只需要写个单侧，springboot已经完美集成mybatis1234567891011@RunWith(SpringRunner.class)@SpringBootTestpublic class ApplicationTests { @Autowired UserMapper userMapper; @Test public void testMybatis() { System.out.println(userMapper.selectByPrimaryKey(1L)); }} @EnableAutoConfiguration通过上面的例子，我们发现集成mybatis特别简单，那些繁琐的类的注入都没有写，只需要加入数据库的一些配置即可，那这其中@EnableAutoConfiguration功不可没。@EnableAutoConfiguration 注解已经在@SpringBootApplication里面了1234567891011121314151617181920212223242526272829303132333435363738@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class}), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class})})public @interface SpringBootApplication { @AliasFor( annotation = EnableAutoConfiguration.class ) Class&lt;?&gt;[] exclude() default {}; @AliasFor( annotation = EnableAutoConfiguration.class ) String[] excludeName() default {}; @AliasFor( annotation = ComponentScan.class, attribute = \"basePackages\" ) String[] scanBasePackages() default {}; @AliasFor( annotation = ComponentScan.class, attribute = \"basePackageClasses\" ) Class&lt;?&gt;[] scanBasePackageClasses() default {};} 我们看到@EnableAutoConfiguration结构如下：12345678910111213@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import({AutoConfigurationImportSelector.class})public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = \"spring.boot.enableautoconfiguration\"; Class&lt;?&gt;[] exclude() default {}; String[] excludeName() default {};} 这其中起作用的一个重要注解@Import，这个Spring提供的一个注解，可以导入配置类或者Bean到当前类中，我们进入到AutoConfigurationImportSelector类中查看，方法太长，截取核心的两个方法：12345678910111213141516171819202122232425public String[] selectImports(AnnotationMetadata annotationMetadata) { if (!this.isEnabled(annotationMetadata)) { return NO_IMPORTS; } else { AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader); AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); }}protected AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) { if (!this.isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } else { AnnotationAttributes attributes = this.getAttributes(annotationMetadata); List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations = this.removeDuplicates(configurations); Set&lt;String&gt; exclusions = this.getExclusions(annotationMetadata, attributes); this.checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = this.filter(configurations, autoConfigurationMetadata); this.fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions); }} 通过项目启动后，打上注解，可以看到MybatisAutoConfiguration引入了进来而MybatisAutoConfiguration能引入进来，其实是在mybatis-spring-boot-autoconfigure-2.0.1.jar包里面的spring.factories指定的,通过调用SpringFactoriesLoader.loadFactoryNames()来扫描加载含有META-INF/spring.factories文件的jar包，从而标识哪些自动配置的类123# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration @Conditional@Conditional 的作用，可以根据条件去加载特定的bean，原理这边不做探讨，springboot基于此实现了几个注解，比较方便的实现条件加载类@ConditionalOnBean：Spring容器中是否存在对应的实例@ConditionalOnMissingBean：Spring容器中是否缺少对应的实例通过查看MybatisAutoConfiguration中的SqlSessionFactory的写法1234567891011121314151617181920212223242526272829303132333435363738394041@Bean@ConditionalOnMissingBeanpublic SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception { SqlSessionFactoryBean factory = new SqlSessionFactoryBean(); factory.setDataSource(dataSource); factory.setVfs(SpringBootVFS.class); if (StringUtils.hasText(this.properties.getConfigLocation())) { factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation())); } this.applyConfiguration(factory); if (this.properties.getConfigurationProperties() != null) { factory.setConfigurationProperties(this.properties.getConfigurationProperties()); } if (!ObjectUtils.isEmpty(this.interceptors)) { factory.setPlugins(this.interceptors); } if (this.databaseIdProvider != null) { factory.setDatabaseIdProvider(this.databaseIdProvider); } if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) { factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage()); } if (this.properties.getTypeAliasesSuperType() != null) { factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType()); } if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) { factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage()); } if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) { factory.setMapperLocations(this.properties.resolveMapperLocations()); } return factory.getObject();} 结语通过上面分析mybatis如何集成springboot，知道了springboot入口在哪里以及如何实现的自动配置，这里只是简单的做了介绍，其中的一些源码和细节就没有分析了，我相信，入口知道了，接下来就好抠细节了。","link":"/2019/04/24/springboot/"}],"tags":[],"categories":[{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"redis","slug":"redis","link":"/categories/redis/"},{"name":"springboot","slug":"springboot","link":"/categories/springboot/"},{"name":"go","slug":"go","link":"/categories/go/"}]}