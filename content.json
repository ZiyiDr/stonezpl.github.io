{"pages":[{"title":"张珮磊想静静","text":"简介本博客主要维护人张珮磊(别问我静静是谁，我只是想而已)，毕业于重庆邮电大学计算机专业，代码写多了，总会感到技术有种小小的无奈，但希望技术能够给生活带去一点点美好 联系方式微信: zplxjj","link":"/about/index.html"},{"title":"tags","text":"#ddd","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"linux 常用命令(持续更新)","text":"查看磁盘空间大小 查看磁盘空间大小: df -h 查看指定目录大小: du -sh &lt;目录名&gt; du -h [目录名]：查看指定文件夹下的所有文件大小（包含子文件夹) 对文件大小进行排序(进入当前目录下)： 文本查询相关 统计某个词出现频率 统计单词次数并按次数排序(每一行为一个单词): 按照分隔符分词，然后排序，去重： 查看端口占用 查看端口占用进程和进程占用端口","link":"/2019/04/01/linux/"},{"title":"redis分布式锁——简单实现","text":"前言最近项目当中需要处理分布式系统中的并发问题，自然地想到了引入分布式锁，本文旨在讲述用redis简单的实现分布式锁，对于复杂的类似于redis集群问题、为什么不用zk等，自己也在学习，希望可以以后有机会分享 分布式锁的可靠性保证 在过期时间内，只有一个客户端持有锁 在客户端持有锁期间短暂崩溃或者redis发生短暂崩溃时，不会有死锁状态 加锁和解锁必须是同一客户端，加锁和解锁必须是同一个客户端 代码实现 项目当中的实现12345678910111213141516171819202122232425262728293031323334353637383940414243public static Boolean lock(String key) { Long nowTIme = System.nanoTime(); //TIMEOUT_NANO：超时时间 while (TIMEOUT_NANO &gt; System.nanoTime() - nowTIme) { long expires = System.nanoTime() + EXPIRE_NANO; //锁到期时间 String expiresStr = String.valueOf(expires); //putIfAbsent: setnx命令 if (putIfAbsent(key, expiresStr)) { return true; } //当redis存在这个key的时候，取出这个key，判断是否超时 String currentValue = get(key); //判断锁是否已经过期，过期则重新设置并获取 if (currentValue != null) { if(Long.parseLong(currentValue) &lt; System.nanoTime() - EXPIRE_NANO){ //设置锁并返回旧值：getSet String oldValue = getAndSet(key, expiresStr); //比较锁的时间，如果不一致则可能是其他锁已经修改了值并获取 if (oldValue != null &amp;&amp; oldValue.equals(currentValue)) { return true; } }else { return false; } } } throw new RuntimeException(\"get redis lock timeout,key=[\" + key + \"]\");}public static Boolean unlock(String key) { if (StringUtils.isBlank(key)) { return false; } try { //redis的del命令 del(key); } catch (Exception e) { log.error(\"redis unlock exception, key={}\", key, e); return false; } return true;} 项目中代码存在的问题 过期时间调用的是: System.nanoTime(),这就需要客户端的时间必须同步 getAndSet 虽然只有一个客户端可以获取锁，但是会覆盖过期时间 锁不具备拥有者标识，相当于所有客户端都拥有相同的key，且对应的value区分不出客户端，即任何客户端都可以解锁。举例：客户端A加锁，一段时间之后客户端A解锁，在执行删除key之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了。 加锁过程优化 加锁原理：基于redis的set命令，value为每个客户端唯一的id，10000为过期时间，相当于setex和setnx两条命令的整合 解锁原理(摘抄网上一段方法)123456789//eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令,保证了其原子性public static boolean del(Jedis jedis, String key, String requestId) { String script = \"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end\"; Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId)); if (RELEASE_SUCCESS.equals(result)) { return true; } return false; }","link":"/2019/04/03/redis/"},{"title":"springboot(一)——搭建属于自己的springboot项目","text":"idea使用spring Initalizr 快速构建spring boot 点击新建项目,选择如图所示 点击next后 点击next，之后按照图中所示选择 选择路径 点击完成，如图所示，删除自己不想要的，项目构建完成 构建一个controller，启动项目就可以看到返回结果了 在自己的服务器搭建自己的springboot项目使用idea向远程服务传递项目 设置idea 配置相关信息 上传到指定机器 配置启动脚本，基于java -jar命令 start.sh 12#!/bin/bashnohup java -jar target/zplxjj.jar &amp; stop.sh 12345678910#!/bin/bashPID=$(ps -ef | grep target/zplxjj.jar | grep -v grep | awk &apos;{ print $2 }&apos;)if [ -z &quot;$PID&quot; ]then echo Application is already stoppedelse echo kill $PID kill $PIDfi~ run.sh 12345#!/bin/bashecho stop applicationsource stop.shecho start applicationsource start.sh 启动自己的项目只需要执行run.sh就行，一个自己的spring boot就搭建起来了 logback配置实际项目中，我们希望日志可以记录在服务器上面，这边用的是logback，是springboot自带的，我这边集成方式是加入logback-spring.xml文件，加入后启动项目即可，文件内容如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;!--用来定义变量值的标签--&gt; &lt;property name=\"LOG_HOME\" value=\"./logs\"/&gt; &lt;property name=\"encoding\" value=\"UTF-8\"/&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度；%M:%L是方法和行号；%msg是日志消息；%n是换行符--&gt; &lt;property name=\"normal-pattern\" value=\"%d{yyyy-MM-dd/HH:mm:ss.SSS}|%X{localIp}|%X{requestId}|%X{requestSeq}|%X{country}|%X{deviceType}|%X{deviceId}|%X{userId}|^_^|[%t] %-5level %logger{50} %line - %m%n\"/&gt; &lt;property name=\"plain-pattern\" value=\"%d{yyyy-MM-dd.HH:mm:ss} %msg%n\"/&gt; &lt;!-- 按照每天生成日志文件 --&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;!--日志文件输出的文件名--&gt; &lt;file&gt;${LOG_HOME}/zplxjj.log&lt;/file&gt; &lt;Append&gt;true&lt;/Append&gt; &lt;prudent&gt;false&lt;/prudent&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;pattern&gt;${normal-pattern}&lt;/pattern&gt; &lt;charset&gt;${encoding}&lt;/charset&gt; &lt;/encoder&gt; &lt;!--按时间分割--&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;${LOG_HOME}/zplxjj.log.%d{yyyy-MM-dd}.%i&lt;/fileNamePattern&gt; &lt;maxFileSize&gt;128MB&lt;/maxFileSize&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;totalSizeCap&gt;32GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;!--控制台输出--&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder class=\"ch.qos.logback.classic.encoder.PatternLayoutEncoder\"&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;${normal-pattern}&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- log file error --&gt; &lt;appender name=\"ERROR\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt; &lt;file&gt;${LOG_HOME}/zplxjj-error.log&lt;/file&gt; &lt;prudent&gt;false&lt;/prudent&gt; &lt;Append&gt;true&lt;/Append&gt; &lt;encoder&gt; &lt;pattern&gt;${normal-pattern}&lt;/pattern&gt; &lt;charset&gt;${encoding}&lt;/charset&gt; &lt;/encoder&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;${LOG_HOME}/zplxjj-error.log.%d{yyyy-MM-dd}.%i&lt;/fileNamePattern&gt; &lt;maxFileSize&gt;128MB&lt;/maxFileSize&gt; &lt;maxHistory&gt;15&lt;/maxHistory&gt; &lt;totalSizeCap&gt;32GB&lt;/totalSizeCap&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"STDOUT\"/&gt; &lt;appender-ref ref=\"FILE\"/&gt; &lt;appender-ref ref=\"ERROR\"/&gt; &lt;/root&gt;&lt;/configuration&gt; 效果如图：","link":"/2019/04/16/springboot/"}],"tags":[],"categories":[{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"redis","slug":"redis","link":"/categories/redis/"},{"name":"springboot","slug":"springboot","link":"/categories/springboot/"}]}